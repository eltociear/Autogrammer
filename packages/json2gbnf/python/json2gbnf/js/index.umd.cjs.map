{"version":3,"file":"index.umd.cjs","sources":["../src/constants/grammar-keys.ts","../src/utils/get-id.ts","../src/utils/replace.ts","../src/constants/grammar-definitions/array.gbnf?raw","../src/constants/grammar-definitions/object.gbnf?raw","../src/constants/grammar-definitions/string.gbnf?raw","../src/constants/grammar-definitions/integer.gbnf?raw","../src/constants/grammar-definitions/number.gbnf?raw","../src/constants/grammar-definitions/null.gbnf?raw","../src/constants/grammar-definitions/boolean.gbnf?raw","../src/constants/grammar-definitions/char.gbnf?raw","../src/constants/grammar-definitions/whitespace.gbnf?raw","../src/constants/grammar-definitions/whitespace-repeating.gbnf?raw","../src/constants/grammar-definitions.ts","../src/constants/constants.ts","../src/utils/join.ts","../src/utils/build-grammar.ts","../src/utils/get-const-key.ts","../src/utils/build-arr.ts","../src/utils/get-whitespace.ts","../src/utils/get-const-rule.ts","../src/grammar.ts","../src/type-guards.ts","../src/utils/get-const-definition.ts","../src/utils/parse-array.ts","../src/utils/get-all-permutations.ts","../src/utils/parse-enum.ts","../src/utils/get-property-definition.ts","../src/utils/parse-object.ts","../src/utils/parse-string.ts","../src/utils/parse-number.ts","../src/utils/parse-type.ts","../src/utils/parse.ts","../src/json2gbnf.ts","../src/umd.ts"],"sourcesContent":["export const VALUE_KEY = 'val';\nexport const OBJECT_KEY = 'obj';\nexport const ARRAY_KEY = 'arr';\nexport const STRING_KEY = 'str';\nexport const NUMBER_KEY = 'num';\nexport const BOOLEAN_KEY = 'bol';\nexport const NULL_KEY = 'nll';\nexport const CHAR_KEY = 'chr';\nexport const INTEGER_KEY = 'int';\nexport const COMMA_KEY = 'com';\nexport const COLON_KEY = 'col';\nexport const QUOTE_KEY = 'qot';\nexport const LEFT_BRACKET_KEY = 'lbkt';\nexport const RIGHT_BRACKET_KEY = 'rbkt';\nexport const LEFT_BRACE_KEY = 'lbrc';\nexport const RIGHT_BRACE_KEY = 'rbrc';\nexport const WHITESPACE_KEY = 'ws';\nexport const WHITESPACE_REPEATING_KEY = 'wss';\n\nexport const KEYS: Record<string, string> = {\n  VALUE_KEY,\n  OBJECT_KEY,\n  ARRAY_KEY,\n  STRING_KEY,\n  NUMBER_KEY,\n  BOOLEAN_KEY,\n  NULL_KEY,\n  CHAR_KEY,\n  INTEGER_KEY,\n  COMMA_KEY,\n  COLON_KEY,\n  QUOTE_KEY,\n  LEFT_BRACKET_KEY,\n  RIGHT_BRACKET_KEY,\n  LEFT_BRACE_KEY,\n  RIGHT_BRACE_KEY,\n  WHITESPACE_KEY,\n  WHITESPACE_REPEATING_KEY,\n};\n","export const getID = (i: number): string => (\n  (i >= 26 ? getID(((i / 26) >> 0) - 1) : \"\") +\n  \"abcdefghijklmnopqrstuvwxyz\"[i % 26 >> 0]\n);\n\n","import { KEYS, } from '../constants/grammar-keys.js';\n\nconst GBNF_KEY_REPLACEMENT_PATTERN = /{{(.*?)}}/g;\n\nexport const replace = (def: unknown): string => {\n  if (typeof def !== 'string') {\n    throw new Error(`Expected string for ${JSON.stringify(def)}`);\n  }\n  return def.trim().replace(GBNF_KEY_REPLACEMENT_PATTERN, (_, inner: string) => {\n    const key = KEYS[inner];\n    if (!key) {\n      throw new Error(`Unknown key ${inner} for def ${def}`);\n    }\n    return key;\n  });\n};\n","export default \"\\\"[\\\" ({{VALUE_KEY}} (\\\",\\\" {{VALUE_KEY}})*)? \\\"]\\\"\\n\"","export default \"\\\"{\\\" ({{STRING_KEY}} \\\":\\\" {{VALUE_KEY}} (\\\",\\\" {{STRING_KEY}} \\\":\\\" {{VALUE_KEY}})*)? \\\"}\\\" \\n\"","export default \"  \\\"\\\\\\\"\\\" ({{CHAR_KEY}})* \\\"\\\\\\\"\\\"\\n\"","export default \"(\\\"-\\\"? ([0-9] | [1-9] [0-9]*)) (\\\".\\\" [0]+)? \\n\"","export default \"(\\\"-\\\"? ([0-9] | [1-9] [0-9]*)) (\\\".\\\" [0-9]+)? ([eE] [-+]? [0-9]+)?\\n\"","export default \"\\\"null\\\"\\n\"","export default \"\\\"true\\\" | \\\"false\\\"\\n\"","export default \"(\\n  [^\\\"\\\\\\\\\\\\x7F\\\\x00-\\\\x1F] |\\n   \\\"\\\\\\\\\\\" ([\\\"\\\\\\\\/bfnrt] | \\\"u\\\" [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]) # escapes\\n  )\\n\"","export default \"[ \\\\t\\\\n]\\n\"","export default \"({{WHITESPACE_KEY}} {{WHITESPACE_REPEATING_KEY}})?\\n\"","import { replace, } from '../utils/replace.js';\nimport _arrayDef from './grammar-definitions/array.gbnf?raw' assert { type: 'text' };\nimport _objectDef from './grammar-definitions/object.gbnf?raw' assert { type: 'text' };\nimport _stringDef from './grammar-definitions/string.gbnf?raw' assert { type: 'text' };\nimport _integerDef from './grammar-definitions/integer.gbnf?raw' assert { type: 'text' };\nimport _numberDef from './grammar-definitions/number.gbnf?raw' assert { type: 'text' };\nimport _nullDef from './grammar-definitions/null.gbnf?raw' assert { type: 'text' };\nimport _boolDef from './grammar-definitions/boolean.gbnf?raw' assert { type: 'text' };\nimport _charDef from './grammar-definitions/char.gbnf?raw' assert { type: 'text' };\nimport _whitespaceDef from './grammar-definitions/whitespace.gbnf?raw' assert { type: 'text' };\nimport _whitespaceRepeatingDef from './grammar-definitions/whitespace-repeating.gbnf?raw' assert { type: 'text' };\n\nexport const arrayDef = replace(_arrayDef);\nexport const objectDef = replace(_objectDef);\nexport const numberDef = replace(_numberDef);\nexport const integerDef = replace(_integerDef);\nexport const stringDef = replace(_stringDef);\nexport const boolDef = replace(_boolDef);\nexport const nullDef = replace(_nullDef);\nexport const charDef = replace(_charDef);\nexport const whitespaceDef = replace(_whitespaceDef);\nexport const whitespaceRepeatingDef = replace(_whitespaceRepeatingDef);\n","import {\n  objectDef,\n  arrayDef,\n  stringDef,\n  numberDef,\n  boolDef,\n  nullDef,\n  charDef,\n  integerDef,\n  whitespaceDef,\n  whitespaceRepeatingDef,\n} from './grammar-definitions.js';\nimport {\n  VALUE_KEY,\n  OBJECT_KEY,\n  ARRAY_KEY,\n  STRING_KEY,\n  NUMBER_KEY,\n  BOOLEAN_KEY,\n  NULL_KEY,\n  CHAR_KEY,\n  INTEGER_KEY,\n  COMMA_KEY,\n  COLON_KEY,\n  QUOTE_KEY,\n  LEFT_BRACKET_KEY,\n  RIGHT_BRACKET_KEY,\n  LEFT_BRACE_KEY,\n  RIGHT_BRACE_KEY,\n  WHITESPACE_KEY,\n  WHITESPACE_REPEATING_KEY,\n} from './grammar-keys.js';\n\nexport const JSON_ALL_VALID_VALUES = `${OBJECT_KEY} | ${ARRAY_KEY} | ${STRING_KEY} | ${NUMBER_KEY} | ${BOOLEAN_KEY} | ${NULL_KEY}`;\nexport const GLOBAL_CONSTANTS = [\n  `${VALUE_KEY} ::= ${JSON_ALL_VALID_VALUES}`,\n  `${OBJECT_KEY} ::= ${objectDef}`,\n  `${ARRAY_KEY} ::= ${arrayDef}`,\n  `${STRING_KEY} ::= ${stringDef}`,\n  `${NUMBER_KEY} ::= ${numberDef}`,\n  `${BOOLEAN_KEY} ::= ${boolDef}`,\n  `${NULL_KEY} ::= ${nullDef}`,\n  `${CHAR_KEY} ::= ${charDef}`,\n  `${INTEGER_KEY} ::= ${integerDef}`,\n  `${COMMA_KEY} ::= \",\"`,\n  `${COLON_KEY} ::= \":\"`,\n  `${QUOTE_KEY} ::= \"\\\\\"\"`,\n  `${LEFT_BRACKET_KEY} ::= \"[\"`,\n  `${RIGHT_BRACKET_KEY} ::= \"]\"`,\n  `${LEFT_BRACE_KEY} ::= \"{\"`,\n  `${RIGHT_BRACE_KEY} ::= \"}\"`,\n  `${WHITESPACE_KEY} ::= ${whitespaceDef}`,\n  `${WHITESPACE_REPEATING_KEY} ::= ${whitespaceRepeatingDef}`,\n];\n","type Value = unknown;\nexport const join = (...arr: Value[]): string => joinWith(' ', ...arr);\nexport const joinWith = (joiner: string, ...arr: Value[]): string => arr.filter(Boolean).join(joiner);\n","import { GLOBAL_CONSTANTS, } from \"../constants/constants.js\";\nimport { joinWith, } from \"./join.js\";\n\nexport const buildGrammar = (entries: IterableIterator<[string, string]>): string => {\n  const rules: string[] = [];\n  for (const [rule, key,] of entries) {\n    if (key === '') {\n      throw new Error('Key cannot be an empty string');\n    }\n\n    if (rule === '') {\n      throw new Error('Rule cannot be an empty string');\n    }\n    rules.push(`${key} ::= ${rule}`);\n  }\n  return joinWith('\\n',\n    ...rules,\n    ...GLOBAL_CONSTANTS,\n  );\n};\n","import { joinWith, } from \"./join.js\";\n\nexport const getConstKey = (key: string, left: boolean, right: boolean): string => joinWith(\n  '',\n  left ? 'ws' : undefined,\n  key,\n  right ? 'ws' : undefined,\n);\n","import { join, } from \"./join.js\";\n\nexport const buildArr = (n: number, content: string): string => {\n  if (n < 0 || !Number.isInteger(n)) {\n    throw new Error('n must be a non-negative integer');\n  }\n  const arr: string[] = [];\n  for (let i = 0; i < n; i++) {\n    arr.push(content);\n  }\n  return join(...arr);\n};\n","import {\n  WHITESPACE_KEY,\n  WHITESPACE_REPEATING_KEY,\n} from \"../constants/grammar-keys.js\";\nimport type {\n  Grammar,\n} from \"../grammar.js\";\nimport { buildArr, } from \"./build-arr.js\";\n\nexport const getWhitespace = (\n  parser: Grammar,\n) => parser.whitespace !== Infinity ? parser.addRule(buildArr(\n  parser.whitespace,\n  `(${WHITESPACE_KEY})?`\n)) : WHITESPACE_REPEATING_KEY;\n","import { Grammar, } from \"../grammar.js\";\nimport { getWhitespace, } from \"./get-whitespace.js\";\nimport { join, } from \"./join.js\";\n\nexport const getConstRule = (\n  parser: Grammar,\n  key: string,\n  left: boolean,\n  right: boolean,\n): string => join(\n  left ? getWhitespace(parser) : undefined,\n  key,\n  right ? getWhitespace(parser) : undefined,\n);\n","import { getID, } from './utils/get-id.js';\nimport type {\n  AddRule,\n  GetConst,\n  SchemaOpts,\n} from './types.js';\nimport { buildGrammar, } from './utils/build-grammar.js';\nimport { getConstKey, } from './utils/get-const-key.js';\nimport { getConstRule, } from './utils/get-const-rule.js';\n\nexport class Grammar {\n  #rules = new Map<string, string>();\n  fixedOrder: boolean;\n  // whitespace can be Infinity or an integer greater than or equal to 0.\n  whitespace: number;\n\n  constructor({ whitespace = 1, fixedOrder = false, }: SchemaOpts = {}) {\n    if (whitespace < 0) {\n      throw new Error('Whitespace must be greater than or equal to 0. It can also be infinity.');\n    }\n    this.whitespace = whitespace;\n    this.fixedOrder = fixedOrder;\n  }\n\n  getConst: GetConst = (\n    key: string,\n    {\n      left = true,\n      right = true,\n    } = {}\n  ) => this.whitespace !== 0 ? this.addRule(\n    getConstRule(this, key, left, right),\n    getConstKey(key, left, right),\n  ) : key;\n\n  addRule: AddRule = (\n    rule,\n    key,\n  ) => {\n    const symbolId = key ? key : (this.#rules.get(rule) ?? `x${getID(this.#rules.size)}`);\n    this.#rules.set(rule, symbolId);\n    return symbolId;\n  };\n\n  get grammar(): string {\n    return buildGrammar(this.#rules.entries());\n  }\n}\n","/* eslint-disable @typescript-eslint/ban-types */\nimport type {\n  JSONSchema,\n  JSONSchemaArray,\n  JSONSchemaArrayBooleanItem,\n  JSONSchemaArrayMultipleItemType,\n  JSONSchemaArrayNoItemType,\n  JSONSchemaArraySingularItemType,\n  JSONSchemaMultipleBasicTypes,\n  JSONSchemaNumber,\n  JSONSchemaObject,\n  JSONSchemaObjectValueConst,\n  JSONSchemaObjectValueEnum,\n  JSONSchemaString,\n} from \"./types.js\";\n\nconst isObject = (schema: unknown): schema is Record<string, unknown> => typeof schema === 'object' && schema !== null;\n\nexport const isSchemaMultipleBasicTypes = (\n  schema: unknown\n): schema is JSONSchemaMultipleBasicTypes => isObject(schema) && 'type' in schema && Array.isArray(schema['type']);\nexport const isSchemaEnum = (\n  schema: unknown\n): schema is JSONSchemaObjectValueEnum => isObject(schema) && 'enum' in schema;\nexport const isSchemaConst = (\n  schema: unknown\n): schema is JSONSchemaObjectValueConst => isObject(schema) && 'const' in schema;\nexport const isSchemaObject = (\n  schema: unknown\n): schema is JSONSchemaObject => isObject(schema) && 'type' in schema && schema['type'] === 'object';\nexport const isEmptyObject = (\n  schema: JSONSchema | {}\n): schema is {} => typeof schema === 'object' && Object.keys(schema).filter(key => {\n  return key !== '$schema';\n}).length === 0;\nexport const hasDollarSchemaProp = (\n  schema: unknown\n): schema is {\n  $schema: string;\n} => isObject(schema) && '$schema' in schema && schema['$schema'] !== undefined;\n// export type JSONSchemaArray = (\n//   BaseJSONSchemaArray | // _no_ type is a valid type of array\n//   JSONSchemaArrayMultipleItemType |\n//   JSONSchemaArraySingularItemType | \n//   JSONSchemaArrayBooleanItem\n// ) & BaseJSONSchemaArray;\n\nexport const isSchemaArrayWithoutItems = (\n  schema: JSONSchemaArray\n): schema is JSONSchemaArrayNoItemType => !('items' in schema) || schema.items === undefined;\nexport const isSchemaArrayWithBooleanItemsType = (\n  schema: JSONSchemaArray\n): schema is JSONSchemaArrayBooleanItem => 'items' in schema && typeof schema.items === 'boolean';\nexport const isSchemaArraySingularItemsType = (\n  schema: JSONSchemaArray\n): schema is JSONSchemaArraySingularItemType => 'items' in schema && typeof schema.items === 'object' && Array.isArray(schema.items.type) === false;\nexport const isSchemaArrayMultipleItemsType = (\n  schema: JSONSchemaArray\n): schema is JSONSchemaArrayMultipleItemType => 'items' in schema && typeof schema.items === 'object' && Array.isArray(schema.items.type) === true;\n\nexport const isSchemaString = (\n  schema: unknown\n): schema is JSONSchemaString => isObject(schema) && 'type' in schema && schema['type'] === 'string';\nexport const isSchemaNumber = (\n  schema: unknown\n): schema is JSONSchemaNumber => isObject(schema) && 'type' in schema && (schema['type'] === 'number' || schema['type'] === 'integer');\n","import { QUOTE_KEY, } from \"../constants/grammar-keys.js\";\nimport type { JSONSchemaObjectValueConst, } from \"../types.js\";\n\nexport const getConstDefinition = (value: JSONSchemaObjectValueConst) => ([\n  QUOTE_KEY,\n  `\"${value.const}\"`,\n  QUOTE_KEY,\n]);\n","import {\n  ARRAY_KEY,\n  COMMA_KEY,\n  LEFT_BRACKET_KEY,\n  RIGHT_BRACKET_KEY,\n} from '../constants/grammar-keys.js';\nimport { join, joinWith, } from './join.js';\nimport { KEYS, } from '../constants/grammar-keys.js';\nimport type {\n  JSONSchemaArray,\n  PrimitiveType,\n} from '../types.js';\nimport type {\n  Grammar,\n} from '../grammar.js';\nimport {\n  isSchemaArrayWithBooleanItemsType,\n  isSchemaArrayWithoutItems,\n} from '../type-guards.js';\n\nconst UNSUPPORTED_PROPERTIES: (keyof JSONSchemaArray)[] = [\n  'prefixItems',\n  'unevaluatedItems',\n  'contains',\n  'minContains',\n  'maxContains',\n  'minItems',\n  'maxItems',\n  'uniqueItems',\n];\n\nexport const parseArray = (\n  parser: Grammar,\n  schema: JSONSchemaArray,\n): string => {\n  for (const key of UNSUPPORTED_PROPERTIES) {\n    if (schema[key] !== undefined) {\n      throw new Error(`${key} is not supported`);\n    }\n  }\n  if (isSchemaArrayWithBooleanItemsType(schema)) {\n    throw new Error('boolean items is not supported, because prefixItems is not supported');\n  }\n  if (isSchemaArrayWithoutItems(schema)) {\n    return ARRAY_KEY;\n  }\n  const types = ([] as PrimitiveType[]).concat(schema.items.type).map((type: string) => KEYS[`${type.toUpperCase()}_KEY`] ?? type);\n  const symbolId = types.length > 1 ? parser.addRule(joinWith(' | ', ...types)) : types[0];\n  return join(\n    parser.getConst(LEFT_BRACKET_KEY, { left: false, }),\n    `(${symbolId} (${parser.getConst(COMMA_KEY)} ${symbolId})*)?`,\n    parser.getConst(RIGHT_BRACKET_KEY, { right: false, }),\n  );\n};\n","export const getAllPermutations = (array: string[], required: string[] = []): string[][] => {\n  const result: string[][] = [];\n\n  function generate(current: string[], remaining: string[]) {\n    if (current.length > 0) {\n      result.push([...current,]);\n    }\n    for (let i = 0; i < remaining.length; i++) {\n      current.push(remaining[i]);\n      generate(current, remaining.slice(0, i).concat(remaining.slice(i + 1)));\n      current.pop();\n    }\n  }\n\n  generate([], array);\n  if (required.length === 0) {\n    return result;\n  }\n  const filteredPermutations = result.filter(permutation => {\n    let valid = true;\n    for (const key of required) {\n      if (!permutation.includes(key)) {\n        valid = false;\n        break;\n      }\n    }\n    return valid;\n  });\n  return filteredPermutations;\n};\n","import { QUOTE_KEY, } from \"../constants/grammar-keys.js\";\nimport { join, } from \"./join.js\";\nimport {\n  AddRule,\n  JSONSchemaObjectValueEnum,\n} from \"../types.js\";\n\nexport const parseEnum = (\n  schema: JSONSchemaObjectValueEnum,\n  addRule: AddRule,\n) => addRule(schema.enum.map(value => join(QUOTE_KEY, `\"${value}\"`, QUOTE_KEY)).join(' | '));\n","import { COLON_KEY, QUOTE_KEY, STRING_KEY, VALUE_KEY, } from \"../constants/grammar-keys.js\";\nimport { join, } from \"./join.js\";\n\nexport const getPropertyDefinition = (SEPARATOR: string): string => {\n  const PROP = [\n    SEPARATOR,\n    QUOTE_KEY,\n    STRING_KEY,\n    QUOTE_KEY,\n    COLON_KEY,\n    VALUE_KEY,\n  ];\n  return `(${join(\n    ...PROP,\n    `(${join(...PROP,)})*`,\n  )})?`;\n};\n","import { getAllPermutations, } from './get-all-permutations.js';\nimport { parseEnum, } from './parse-enum.js';\nimport {\n  COLON_KEY,\n  COMMA_KEY,\n  LEFT_BRACE_KEY,\n  OBJECT_KEY,\n  QUOTE_KEY,\n  RIGHT_BRACE_KEY,\n} from '../constants/grammar-keys.js';\nimport {\n  JSONSchemaObject,\n  JSONSchemaValue,\n} from '../types.js';\nimport { parseType, } from './parse-type.js';\nimport { Grammar, } from '../grammar.js';\nimport {\n  join,\n  joinWith,\n} from './join.js';\nimport {\n  isSchemaConst,\n  isSchemaEnum,\n} from '../type-guards.js';\nimport { getPropertyDefinition, } from './get-property-definition.js';\nimport { getConstDefinition, } from './get-const-definition.js';\n\nconst UNSUPPORTED_PROPERTIES: (keyof JSONSchemaObject)[] = [\n  'patternProperties',\n  'allOf',\n  'unevaluatedProperties',\n  'propertyNames',\n  'minProperties',\n  'maxProperties',\n];\n\nconst getPropertiesValue = (grammar: Grammar, value: JSONSchemaValue): string[] => {\n  if (isSchemaConst(value)) {\n    return getConstDefinition(value);\n  }\n  if (isSchemaEnum(value)) {\n    return [parseEnum(value, grammar.addRule),];\n  }\n  return [parseType(grammar, value),];\n};\n\nexport const parseObject = (\n  grammar: Grammar,\n  schema: JSONSchemaObject,\n) => {\n  for (const key of UNSUPPORTED_PROPERTIES) {\n    if (key in schema) {\n      throw new Error(`${key} is not supported`);\n    }\n  }\n  const { additionalProperties = true, properties, required = [], } = schema;\n  if (properties !== undefined && typeof properties === 'object') {\n    const COLON = grammar.getConst(COLON_KEY);\n    const LB = grammar.getConst(LEFT_BRACE_KEY, { left: false, });\n    const RB = grammar.getConst(RIGHT_BRACE_KEY, { right: false, });\n    const SEPARATOR = grammar.getConst(COMMA_KEY, { left: false, });\n    const PROPERTY_KEY = additionalProperties ? grammar.addRule(getPropertyDefinition(SEPARATOR)) : undefined;\n\n    const objectProperties: { rule: string; key: string }[] = Object.entries(properties).map(([key, value,]) => ({\n      rule: grammar.addRule(join(\n        QUOTE_KEY,\n        `\"${key}\"`,\n        QUOTE_KEY,\n        COLON,\n        ...getPropertiesValue(grammar, value),\n      )),\n      key,\n    }));\n\n    const requiredsToKeys = objectProperties.reduce<Record<string, string>>((acc, { rule, key, }) => ({\n      ...acc,\n      [key]: rule,\n    }), {});\n\n    const rules = objectProperties.map(({ rule, }) => rule);\n\n    if (grammar.fixedOrder) {\n      return join(\n        LB,\n        `(${joinWith(\n          ` ${SEPARATOR} `,\n          ...rules.map((rule, i) => (i === rules.length - 1 && additionalProperties) ? join(rule, PROPERTY_KEY) : rule),\n        )})`,\n        RB,\n      );\n    }\n\n    const requireds = required.map(key => requiredsToKeys[key]);\n\n    const permutations = getAllPermutations(rules, requireds,)\n      .map(permutation => additionalProperties ? permutation.map(perm => join(perm, PROPERTY_KEY)) : permutation)\n      .map(permutation => permutation.length > 1 ? grammar.addRule(\n        joinWith(` ${SEPARATOR} `, ...permutation),\n      ) : permutation[0]);\n\n    return join(\n      LB,\n      `(${joinWith(' | ', ...permutations)})${required.length > 0 ? '' : '?'}`,\n      RB,\n    );\n  }\n\n  return OBJECT_KEY;\n};\n","import {\n  CHAR_KEY,\n  QUOTE_KEY,\n  STRING_KEY,\n} from \"../constants/grammar-keys.js\";\nimport { join, } from \"./join.js\";\nimport { JSONSchemaString, } from \"../types.js\";\n\nexport const parseString = (schema: JSONSchemaString): string => {\n  const { format, pattern, minLength, maxLength, } = schema;\n  if (pattern !== undefined) {\n    throw new Error('pattern is not supported');\n  }\n  if (format !== undefined) {\n    throw new Error('format is not supported');\n  }\n\n  if (minLength !== undefined && maxLength !== undefined) {\n    if (minLength > maxLength) {\n      throw new Error('minLength must be less than or equal to maxLength');\n    }\n    return join(\n      QUOTE_KEY,\n      Array(minLength).fill(CHAR_KEY).join(' '),\n      Array(maxLength - minLength).fill(`(${CHAR_KEY})?`).join(' '),\n      QUOTE_KEY,\n    );\n  } else if (maxLength === undefined && minLength !== undefined) {\n    return join(\n      QUOTE_KEY,\n      Array(minLength - 1).fill(CHAR_KEY).join(' '),\n      `(${CHAR_KEY})+`,\n      QUOTE_KEY,\n    );\n  } else if (minLength === undefined && maxLength !== undefined) {\n    return join(\n      QUOTE_KEY,\n      `${Array(maxLength).fill(`(${CHAR_KEY})?`).join(' ')}`,\n      QUOTE_KEY,\n    );\n  }\n  return STRING_KEY;\n};\n","import { INTEGER_KEY, NUMBER_KEY, } from \"../constants/grammar-keys.js\";\nimport { type JSONSchemaNumber, } from \"../types.js\";\n\n\nconst UNSUPPORTED_NUMERIC_PROPERTIES: (keyof JSONSchemaNumber)[] = [\n  'exclusiveMinimum',\n  'exclusiveMaximum',\n  'multipleOf',\n  'minimum',\n  'maximum',\n];\n\nexport const parseNumber = (schema: JSONSchemaNumber) => {\n  for (const key of UNSUPPORTED_NUMERIC_PROPERTIES) {\n    if (schema[key] !== undefined) {\n      throw new Error(`${key} is not supported`);\n    }\n  }\n  const { type, } = schema;\n  if (type === 'number') {\n    return NUMBER_KEY;\n  } else {\n    return INTEGER_KEY;\n  }\n};\n","import { parseArray, } from './parse-array.js';\nimport { parseObject, } from './parse-object.js';\nimport { parseString, } from './parse-string.js';\nimport {\n  BOOLEAN_KEY,\n  NULL_KEY,\n} from '../constants/grammar-keys.js';\nimport type {\n  ParseTypeArg,\n} from '../types.js';\nimport {\n  type Grammar,\n} from '../grammar.js';\nimport { parseNumber, } from './parse-number.js';\nimport { isSchemaNumber, isSchemaString, } from '../type-guards.js';\n\nexport const parseType = (\n  parser: Grammar,\n  schema: ParseTypeArg,\n): string => {\n  const { type, } = schema;\n  if (type === 'boolean') {\n    return BOOLEAN_KEY;\n  } else if (type === 'null') {\n    return NULL_KEY;\n  } else if (isSchemaString(schema)) {\n    return parseString(schema);\n  } else if (isSchemaNumber(schema)) {\n    return parseNumber(schema);\n  } else if (type === 'array') {\n    return parseArray(parser, schema);\n  } else if (type === 'object') {\n    return parseObject(parser, schema);\n  }\n  throw new Error(`type for schema ${JSON.stringify(schema)} is not supported`);\n};\n","// parse.ts\nimport { KEYS, NULL_KEY, } from \"../constants/grammar-keys.js\";\nimport {\n  type Grammar,\n} from \"../grammar.js\";\nimport {\n  isSchemaConst,\n  isSchemaEnum,\n  isSchemaMultipleBasicTypes,\n} from \"../type-guards.js\";\nimport type {\n  JSONSchema,\n} from \"../types.js\";\nimport { getConstDefinition, } from \"./get-const-definition.js\";\nimport { join, joinWith, } from \"./join.js\";\nimport { parseType, } from \"./parse-type.js\";\n\nexport const parse = (\n  parser: Grammar,\n  schema: JSONSchema,\n  symbolName: string,\n) => {\n  if (isSchemaMultipleBasicTypes(schema)) {\n    // if type is an array, then it must not be a structured data type\n    parser.addRule(\n      joinWith(\n        ' | ',\n        ...schema.type.map(type => {\n          const key = `${type.toUpperCase()}_KEY`;\n          if (!(key in KEYS)) {\n            throw new Error(`Unknown type ${type} for schema ${JSON.stringify(schema)}`);\n          }\n          return KEYS[key];\n        })),\n      symbolName,\n    );\n  } else if (isSchemaEnum(schema)) {\n    parser.addRule(\n      joinWith(\n        \" | \",\n        ...schema.enum.map(e => JSON.stringify(e)).map(type => type === 'null' ? NULL_KEY : JSON.stringify(type))\n      ),\n      symbolName,\n    );\n  } else if (isSchemaConst(schema)) {\n    parser.addRule(\n      join(...getConstDefinition(schema)),\n      symbolName,\n    );\n  } else {\n    parser.addRule(\n      parseType(parser, schema),\n      symbolName,\n    );\n  }\n};\n","import { VALUE_KEY, } from './constants/grammar-keys.js';\nimport {\n  Grammar,\n} from './grammar.js';\nimport {\n  isEmptyObject,\n  hasDollarSchemaProp,\n} from './type-guards.js';\nimport {\n  type JSONSchema,\n  type SchemaOpts,\n} from './types.js';\nimport { parse, } from './utils/parse.js';\n\n// https://json-schema.org/understanding-json-schema/basics\n// false will always be invalid\nexport const BLANK_GRAMMAR = `root ::= \"\"`;\n\nexport function JSON2GBNF<T extends JSONSchema>(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  schema?: {} | null | T | boolean,\n  opts?: SchemaOpts\n): string {\n  if (schema === null || schema === undefined) {\n    throw new Error('Bad schema provided');\n  }\n  if (schema === false) {\n    return BLANK_GRAMMAR;\n  }\n  if (schema !== true && hasDollarSchemaProp(schema) && schema['$schema'] !== 'https://json-schema.org/draft/2020-12/schema') {\n    throw new Error(`Unsupported schema version: ${schema['$schema']}`);\n  }\n\n  const parser = new Grammar(opts);\n  if (schema === true || isEmptyObject(schema)) {\n    parser.addRule(VALUE_KEY, 'root');\n  } else {\n    parse(parser, schema, 'root');\n  }\n\n  return parser.grammar;\n};\n","/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { JSON2GBNF, } from './json2gbnf.js';\n\nmodule.exports = JSON2GBNF;\n"],"names":["VALUE_KEY","OBJECT_KEY","ARRAY_KEY","STRING_KEY","NUMBER_KEY","BOOLEAN_KEY","NULL_KEY","CHAR_KEY","INTEGER_KEY","COMMA_KEY","COLON_KEY","QUOTE_KEY","LEFT_BRACKET_KEY","RIGHT_BRACKET_KEY","LEFT_BRACE_KEY","RIGHT_BRACE_KEY","WHITESPACE_KEY","WHITESPACE_REPEATING_KEY","KEYS","getID","i","GBNF_KEY_REPLACEMENT_PATTERN","replace","def","_","inner","key","_arrayDef","_objectDef","_stringDef","_integerDef","_numberDef","_nullDef","_boolDef","_charDef","_whitespaceDef","_whitespaceRepeatingDef","arrayDef","objectDef","numberDef","integerDef","stringDef","boolDef","nullDef","charDef","whitespaceDef","whitespaceRepeatingDef","JSON_ALL_VALID_VALUES","GLOBAL_CONSTANTS","join","arr","joinWith","joiner","buildGrammar","entries","rules","rule","getConstKey","left","right","buildArr","n","content","getWhitespace","parser","getConstRule","Grammar","#rules","whitespace","fixedOrder","symbolId","isObject","schema","isSchemaMultipleBasicTypes","isSchemaEnum","isSchemaConst","isEmptyObject","hasDollarSchemaProp","isSchemaArrayWithoutItems","isSchemaArrayWithBooleanItemsType","isSchemaString","isSchemaNumber","getConstDefinition","value","UNSUPPORTED_PROPERTIES","parseArray","types","type","getAllPermutations","array","required","result","generate","current","remaining","permutation","valid","parseEnum","addRule","getPropertyDefinition","SEPARATOR","PROP","getPropertiesValue","grammar","parseType","parseObject","additionalProperties","properties","COLON","LB","RB","PROPERTY_KEY","objectProperties","requiredsToKeys","acc","requireds","permutations","perm","parseString","format","pattern","minLength","maxLength","UNSUPPORTED_NUMERIC_PROPERTIES","parseNumber","parse","symbolName","e","BLANK_GRAMMAR","JSON2GBNF","opts"],"mappings":"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"}