(function(a){typeof define=="function"&&define.amd?define(a):a()})(function(){"use strict";const a="val",y="obj",g="arr",R="str",A="num",b="bol",w="nll",d="chr",P="int",h="com",K="col",i="qot",S="lbkt",T="rbkt",m="lbrc",Y="rbrc",C="ws",I="wss",O={VALUE_KEY:a,OBJECT_KEY:y,ARRAY_KEY:g,STRING_KEY:R,NUMBER_KEY:A,BOOLEAN_KEY:b,NULL_KEY:w,CHAR_KEY:d,INTEGER_KEY:P,COMMA_KEY:h,COLON_KEY:K,QUOTE_KEY:i,LEFT_BRACKET_KEY:S,RIGHT_BRACKET_KEY:T,LEFT_BRACE_KEY:m,RIGHT_BRACE_KEY:Y,WHITESPACE_KEY:C,WHITESPACE_REPEATING_KEY:I},v=t=>(t>=26?v((t/26>>0)-1):"")+"abcdefghijklmnopqrstuvwxyz"[t%26>>0],M=/{{(.*?)}}/g,u=t=>{if(typeof t!="string")throw new Error(`Expected string for ${JSON.stringify(t)}`);return t.trim().replace(M,(e,n)=>{const o=O[n];if(!o)throw new Error(`Unknown key ${n} for def ${t}`);return o})},F=`"[" ({{VALUE_KEY}} ("," {{VALUE_KEY}})*)? "]"
`,W=`"{" ({{STRING_KEY}} ":" {{VALUE_KEY}} ("," {{STRING_KEY}} ":" {{VALUE_KEY}})*)? "}" 
`,H=`  "\\"" ({{CHAR_KEY}})* "\\""
`,J=`("-"? ([0-9] | [1-9] [0-9]*)) ("." [0]+)? 
`,V=`("-"? ([0-9] | [1-9] [0-9]*)) ("." [0-9]+)? ([eE] [-+]? [0-9]+)?
`,q=`"null"
`,z=`"true" | "false"
`,Q=`(
  [^"\\\\\\x7F\\x00-\\x1F] |
   "\\\\" (["\\\\/bfnrt] | "u" [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]) # escapes
  )
`,X=`[ \\t\\n]
`,Z=`({{WHITESPACE_KEY}} {{WHITESPACE_REPEATING_KEY}})?
`,tt=u(F),et=u(W),nt=u(V),ot=u(J),rt=u(H),st=u(z),it=u(q),ct=u(Q),ft=u(X),ut=u(Z),lt=`${y} | ${g} | ${R} | ${A} | ${b} | ${w}`,Et=[`${a} ::= ${lt}`,`${y} ::= ${et}`,`${g} ::= ${tt}`,`${R} ::= ${rt}`,`${A} ::= ${nt}`,`${b} ::= ${st}`,`${w} ::= ${it}`,`${d} ::= ${ct}`,`${P} ::= ${ot}`,`${h} ::= ","`,`${K} ::= ":"`,`${i} ::= "\\""`,`${S} ::= "["`,`${T} ::= "]"`,`${m} ::= "{"`,`${Y} ::= "}"`,`${C} ::= ${ft}`,`${I} ::= ${ut}`],c=(...t)=>p(" ",...t),p=(t,...e)=>e.filter(Boolean).join(t),pt=t=>{const e=[];for(const[n,o]of t){if(o==="")throw new Error("Key cannot be an empty string");if(n==="")throw new Error("Rule cannot be an empty string");e.push(`${o} ::= ${n}`)}return p(`
`,...e,...Et)},at=(t,e,n)=>p("",e?"ws":void 0,t,n?"ws":void 0),dt=(t,e)=>{if(t<0||!Number.isInteger(t))throw new Error("n must be a non-negative integer");const n=[];for(let o=0;o<t;o++)n.push(e);return c(...n)},L=t=>t.whitespace!==1/0?t.addRule(dt(t.whitespace,`(${C})?`)):I,$t=(t,e,n,o)=>c(n?L(t):void 0,e,o?L(t):void 0);class _t{#t=new Map;fixedOrder;whitespace;constructor({whitespace:e=1,fixedOrder:n=!1}={}){if(e<0)throw new Error("Whitespace must be greater than or equal to 0. It can also be infinity.");this.whitespace=e,this.fixedOrder=n}getConst=(e,{left:n=!0,right:o=!0}={})=>this.whitespace!==0?this.addRule($t(this,e,n,o),at(e,n,o)):e;addRule=(e,n)=>{const o=n||(this.#t.get(e)??`x${v(this.#t.size)}`);return this.#t.set(e,o),o};get grammar(){return pt(this.#t.entries())}}const _=t=>typeof t=="object"&&t!==null,Rt=t=>_(t)&&"type"in t&&Array.isArray(t.type),j=t=>_(t)&&"enum"in t,x=t=>_(t)&&"const"in t,wt=t=>typeof t=="object"&&Object.keys(t).filter(e=>e!=="$schema").length===0,yt=t=>_(t)&&"$schema"in t&&t.$schema!==void 0,gt=t=>!("items"in t)||t.items===void 0,At=t=>"items"in t&&typeof t.items=="boolean",bt=t=>_(t)&&"type"in t&&t.type==="string",ht=t=>_(t)&&"type"in t&&(t.type==="number"||t.type==="integer"),U=t=>[i,`"${t.const}"`,i],Kt=["prefixItems","unevaluatedItems","contains","minContains","maxContains","minItems","maxItems","uniqueItems"],Ot=(t,e)=>{for(const r of Kt)if(e[r]!==void 0)throw new Error(`${r} is not supported`);if(At(e))throw new Error("boolean items is not supported, because prefixItems is not supported");if(gt(e))return g;const n=[].concat(e.items.type).map(r=>O[`${r.toUpperCase()}_KEY`]??r),o=n.length>1?t.addRule(p(" | ",...n)):n[0];return c(t.getConst(S,{left:!1}),`(${o} (${t.getConst(h)} ${o})*)?`,t.getConst(T,{right:!1}))},Pt=(t,e=[])=>{const n=[];function o(f,l){f.length>0&&n.push([...f]);for(let E=0;E<l.length;E++)f.push(l[E]),o(f,l.slice(0,E).concat(l.slice(E+1))),f.pop()}return o([],t),e.length===0?n:n.filter(f=>{let l=!0;for(const E of e)if(!f.includes(E)){l=!1;break}return l})},St=(t,e)=>e(t.enum.map(n=>c(i,`"${n}"`,i)).join(" | ")),Tt=t=>{const e=[t,i,R,i,K,a];return`(${c(...e,`(${c(...e)})*`)})?`},mt=["patternProperties","allOf","unevaluatedProperties","propertyNames","minProperties","maxProperties"],Yt=(t,e)=>x(e)?U(e):j(e)?[St(e,t.addRule)]:[B(t,e)],Ct=(t,e)=>{for(const f of mt)if(f in e)throw new Error(`${f} is not supported`);const{additionalProperties:n=!0,properties:o,required:r=[]}=e;if(o!==void 0&&typeof o=="object"){const f=t.getConst(K),l=t.getConst(m,{left:!1}),E=t.getConst(Y,{right:!1}),N=t.getConst(h,{left:!1}),G=n?t.addRule(Tt(N)):void 0,k=Object.entries(o).map(([s,$])=>({rule:t.addRule(c(i,`"${s}"`,i,f,...Yt(t,$))),key:s})),xt=k.reduce((s,{rule:$,key:Gt})=>({...s,[Gt]:$}),{}),D=k.map(({rule:s})=>s);if(t.fixedOrder)return c(l,`(${p(` ${N} `,...D.map((s,$)=>$===D.length-1&&n?c(s,G):s))})`,E);const Ut=r.map(s=>xt[s]),Bt=Pt(D,Ut).map(s=>n?s.map($=>c($,G)):s).map(s=>s.length>1?t.addRule(p(` ${N} `,...s)):s[0]);return c(l,`(${p(" | ",...Bt)})${r.length>0?"":"?"}`,E)}return y},It=t=>{const{format:e,pattern:n,minLength:o,maxLength:r}=t;if(n!==void 0)throw new Error("pattern is not supported");if(e!==void 0)throw new Error("format is not supported");if(o!==void 0&&r!==void 0){if(o>r)throw new Error("minLength must be less than or equal to maxLength");return c(i,Array(o).fill(d).join(" "),Array(r-o).fill(`(${d})?`).join(" "),i)}else{if(r===void 0&&o!==void 0)return c(i,Array(o-1).fill(d).join(" "),`(${d})+`,i);if(o===void 0&&r!==void 0)return c(i,`${Array(r).fill(`(${d})?`).join(" ")}`,i)}return R},Nt=["exclusiveMinimum","exclusiveMaximum","multipleOf","minimum","maximum"],Dt=t=>{for(const n of Nt)if(t[n]!==void 0)throw new Error(`${n} is not supported`);const{type:e}=t;return e==="number"?A:P},B=(t,e)=>{const{type:n}=e;if(n==="boolean")return b;if(n==="null")return w;if(bt(e))return It(e);if(ht(e))return Dt(e);if(n==="array")return Ot(t,e);if(n==="object")return Ct(t,e);throw new Error(`type for schema ${JSON.stringify(e)} is not supported`)},vt=(t,e,n)=>{Rt(e)?t.addRule(p(" | ",...e.type.map(o=>{const r=`${o.toUpperCase()}_KEY`;if(!(r in O))throw new Error(`Unknown type ${o} for schema ${JSON.stringify(e)}`);return O[r]})),n):j(e)?t.addRule(p(" | ",...e.enum.map(o=>JSON.stringify(o)).map(o=>o==="null"?w:JSON.stringify(o))),n):x(e)?t.addRule(c(...U(e)),n):t.addRule(B(t,e),n)},Lt='root ::= ""';function jt(t,e){if(t==null)throw new Error("Bad schema provided");if(t===!1)return Lt;if(t!==!0&&yt(t)&&t.$schema!=="https://json-schema.org/draft/2020-12/schema")throw new Error(`Unsupported schema version: ${t.$schema}`);const n=new _t(e);return t===!0||wt(t)?n.addRule(a,"root"):vt(n,t,"root"),n.grammar}module.exports=jt});
//# sourceMappingURL=index.umd.cjs.map
